<template>
  <el-form
    class="b-form"
    ref="formRef"
    :rules="rules"
    :model="formData"
    @submit.prevent.native="onSubmit(formRef, afterSumbmit)"
  >
    <el-row class="b-form__row">
      <el-col
        v-for="group in fields.groups"
        :key="group.code"
        class="b-form__col"
      >
        <el-form-item
          v-for="field in group.items"
          :key="field.code"
          :label="field.title"
          :prop="field.code"
        >
          <template
            v-if="field.type === 'file'"
          >
            <el-upload
              class="b-upload"
              :show-file-list="true"
              :action="uploadFileUrl"
              :on-success="(response, uploadFile) => handleFileUploadSuccess(field.code, response, uploadFile)"
              :before-upload="beforeFileUpload"
              :on-remove="() => removeFile(field.code)"
            >
              <img
                v-if="formData[field.code]?.url"
                :src="formData[field.code].url"
                class="b-upload__img"
                alt="Preview Image"
              />
              <el-icon v-else class="b-upload__icon">
                <Plus />
              </el-icon>
            </el-upload>
          </template>
          <el-select
            v-else-if="field.type === 'select'"
            v-model="formData[field.code]"
            class="b-select"
            popper-class="b-select__popper"
            :placeholder="field.placeholder"
            :class="!!formData[field.code] ? `b-select_selected b-select_selected-${getRoleCodeById(formData[field.code])}` : ''"
          >
            <el-option
              v-for="option in field.items"
              class="b-select__tag"
              :key="option.id"
              :label="option.name"
              :value="option.id"
              :class="'b-select__tag-' + option.code"
            />
          </el-select>
          <el-input
            v-else
            class="b-input"
            v-model="formData[field.code]"
            :placeholder="field.placeholder"
          >
          </el-input>
        </el-form-item>
      </el-col>
      <el-col class="b-form__col b-form__col_bottom">
        <el-button
          class="b-btn b-btn_primary b-btn_large b-btn_full"
          native-type="submit"
          :loading="isLoading"
        >
          Create
        </el-button>
      </el-col>
    </el-row>
  </el-form>
</template>
<script setup>
import {
  ElForm,
  ElFormItem,
  ElCol,
  ElRow,
  ElInput,
  ElSelect,
  ElOption,
  ElUpload,
  ElIcon,
  ElButton,
  ElMessage,
} from 'element-plus';
import { Plus } from '@element-plus/icons-vue';
import { ref, reactive } from 'vue';
import useForm from '@/composable/form';
import { getRoles, createAccount } from '@/api/accounts';
import AccountFormFields from '@/models/AccountFormFields';
import { uploadFileUrl } from '@/api/options';
import { EmailValidatorRegex, AccountRoleFieldCode } from '@/lib/constants';
import Request from '@/lib/request';
import AccountFormValidatorsModel from '@/models/AccountFormValidatorsModel';
import AccountCreateModel from '@/models/AccountCreateModel';
import AccountCreateFileModel from '@/models/AccountCreateFileModel';

const emit = defineEmits(['update']);

const formRef = ref();
const fields = reactive(AccountFormFields);

const {
  formData,
  isLoading,
  rules,
  onSubmit
} = useForm(fields, createAccount, new AccountCreateModel(), new AccountFormValidatorsModel({ email: EmailValidatorRegex }));

const getAccountRoles = async () => {
  await getRoles()
    .then((response) => {
      const roleOptions = response?.data;
      setAccountRoleOptions(roleOptions);
    })
    .catch((error) => {
      console.error('GET error:{accounts/roles}', error);
    });
}

/**
 * @param {Array<Object>} roleOptions
 */
const setAccountRoleOptions = (roleOptions) => {
  if (!roleOptions || roleOptions.length < 0) {
    return;
  }
  (!!fields.groups && fields.groups.length > 0)
      && fields.groups.forEach((group, groupIndex) => {
        (!!group.items && group.items.length > 0)
          && group.items.forEach((field, fieldIndex) => {
            const items = fields.groups[groupIndex].items[fieldIndex].items;
            (!!items && fields.groups[groupIndex].items[fieldIndex].code === AccountRoleFieldCode)
              && (fields.groups[groupIndex].items[fieldIndex].items = roleOptions);
          });
      });
}

/**
 * @param {Number} id
 */
const getRoleCodeById = (id) => {
  if (!id) {
    return '';
  }
  let result = '';
  (!!fields.groups && fields.groups.length > 0)
      && fields.groups.forEach((group, groupIndex) => {
        (!!group.items && group.items.length > 0)
          && group.items.forEach((field, fieldIndex) => {
            const items = fields.groups[groupIndex].items[fieldIndex].items;
            if (!!items && items.length > 0) {
              result = items.filter((item) => item.id === id)[0]?.code;
            }
          });
      });
  return result;
}

/**
 * @param {String} code
 * @param {String} response
 * @param {File} uploadFile
 */
const handleFileUploadSuccess = async (code, response, uploadFile) => {
  ElMessage({
    message: response,
    type: 'success',
  });
  const request = new Request();
  formData[code] = new AccountCreateFileModel({
    file: await request.convertToBase64(uploadFile.raw),
    name: uploadFile.name,
    url: URL.createObjectURL(uploadFile.raw)
  });
}

/**
 * @param {File} rawFile
 */
const beforeFileUpload = (rawFile) => {
  if (rawFile.size / 1024 / 1024 > 2) {
    ElMessage.success('Picture size can not exceed 2MB!');
    return false;
  }
  return true;
}

/**
 * @param {String} code
 */
const removeFile = (code) => {
  formData[code] = null;
}

const afterSumbmit = () => {
  emit('update');
}

getAccountRoles();

</script>
